/*File generated by 'summvalgen'*/

#define NULL ((void*)0)
#define INT_SIZE (sizeof(int) * 8)
#define LONG_SIZE (sizeof(long) * 8)
#define CHAR_SIZE (sizeof(char) * 8)
#define PTR_SIZE (sizeof(void*) * 8)
typedef void* symbolic;
typedef int state_t;
typedef unsigned int size_t;
typedef unsigned int cnstr_t;
typedef unsigned int result_t;

cnstr_t _ULE_(symbolic var1, symbolic var2) {return 0;}
cnstr_t get_cnstr(symbolic var, size_t size) {return 0;}
result_t check_implications(char* constraint1, char* constraint2) {return 0;}
state_t save_current_state() {return 0;}
symbolic sym_var_array(char* name, size_t index, size_t size) {return 0;}
symbolic sym_var_named(char* name, size_t size) {return 0;}
void assume(cnstr_t cnstr) {return;}
void halt_all(state_t state) {return;}
void mem_addr(char* name, void* addr, size_t length) {return;}
void print_counterexamples(result_t result) {return;}
void store_cnstr(char* name, cnstr_t constraint) {return;}

cnstr_t _EQ_(symbolic var1, symbolic var2) {return 0;}
int is_symbolic(symbolic sym_var) {return 0;} 
long maximize(symbolic sym_var){return 0;}

#define POINTER_SIZE 5
#define FUEL 5
#define ARRAY_SIZE_1 5
#define MAX_NUM_1 5


void *concrete_memcpy(void *dest, void *src, size_t n)
{
  unsigned char *str_dest = (unsigned char *) dest;
  unsigned char *str_src = (unsigned char *) src;
  for (int i = 0; i < n; i++)
  {
    unsigned char c = *(str_src + i);
    *(str_dest + i) = c;
  }

  return dest;
}

void *summ_memcpy(void *dest, void *src, size_t n)
{
  if (is_symbolic(n))
  {
    size_t max = maximize(n);
    cnstr_t maximize = _EQ_(n, max);
    assume(maximize);
    n = max;
  }
  unsigned char *str_dest = (unsigned char *) dest;
  unsigned char *str_src = (unsigned char *) src;
  for (int i = 0; i < n; i++)
  {
    unsigned char c = *(str_src + i);
    *(str_dest + i) = c;
  }

  return dest;
}

void test_1()
{
  char dest[ARRAY_SIZE_1];
  for (int dest_idx_1 = 0; dest_idx_1 < ARRAY_SIZE_1; dest_idx_1++)
  {
    dest[dest_idx_1] = sym_var_array("dest", dest_idx_1, sizeof(char) * 8);
  }

  dest[ARRAY_SIZE_1 - 1] = '\0';
  char src[ARRAY_SIZE_1];
  for (int src_idx_1 = 0; src_idx_1 < ARRAY_SIZE_1; src_idx_1++)
  {
    src[src_idx_1] = sym_var_array("src", src_idx_1, sizeof(char) * 8);
  }

  src[ARRAY_SIZE_1 - 1] = '\0';
  size_t n = sym_var_named("n", sizeof(size_t) * 8);
  size_t max_1 = MAX_NUM_1;
  assume(_ULE_(n, max_1));
  state_t initial_state = save_current_state();
  mem_addr("dest", dest, ARRAY_SIZE_1);
  mem_addr("src", src, ARRAY_SIZE_1);
  void* ret1 = concrete_memcpy(dest, src, n);
  cnstr_t cnstr1 = get_cnstr(&ret1, sizeof(void*) * 8);
  store_cnstr("cnctr_test1", cnstr1);
  halt_all(initial_state);
  void* ret2 = summ_memcpy(dest, src, n);
  cnstr_t cnstr2 = get_cnstr(&ret2, sizeof(void*) * 8);
  store_cnstr("summ_test1", cnstr2);
  halt_all(NULL);
  result_t result = check_implications("cnctr_test1", "summ_test1");
  print_counterexamples(result);
  return ;
}

int main()
{
  test_1();
}